# CarND-Path-Planning-Project
Self-Driving Car Engineer Nanodegree Program


## Overview

This project implements a behavioral module and trajectory planner for a simulated self-driving car on a 3-lane highway (that will work for n-lanes).

The complete code was developed in two classes, the vehicle class, and the planner class, all defined in `main.cpp`.

### Vehicle Class

The vehicle class (struct), contains all information pertinant to either the ego vehicle, or other vehicles sensed along the path.

### Planner Class

The planner class holds all way point information, target speed, and ego vehicle information. The class implements the main functions of self-driving car framework, namely, behaviour, and trajectory. Localization, sensor fusion and motion control is provided through the simulator. Prediction is not implemented as it was accounted for through the use of extended distance boundaries when processing sensor data. Future implementations could integrate prediction over the expecting operational horizon.

The planner class implements an FSM-like behavioral control logic for increasing / decreasing speed and executing a lane change. A 'Left-lane passing priority' behaviour is added to ensure the ego vehicle moves to the right lane when it is clear to leave the left lane open for passing vehicles.

The following functions are implemented:

#### 1. reset()

This function resets the lane sensing states for each loop of the program. 

#### 2. updateEgo()

This function updates the current ego trajectory with the previous trajectory and holds a counter for how long the vehicle has spent in the current lane (this is used to smooth trajectories across multiple lanes).

#### 3. checkLanes()

This function checks the neighboring left/right lanes to see if any other vehicles are occupying the lanes within a distance threshold. The distance threshold implicitly accounts for the predicted motion at future timesteps, thus avoiding the need to predict other vehicles positions. This does make the algorithm prone to failure should a vehicle in an adjacent lane be moving much faster than sensor sampling rate. 

#### 4. FSMUpdate()

This is the main behavioral planning function. The function checks every sensed vehicle in the vacinity of the ego vehicle, and determines whether any vehicle exists in the same lane within a set distance, and whether the vehicle's speed is less than the ego vehicles speed.

    if the vehicle in fronted is sensed to be closer than the minimum distance:
        if it's speed is less than the ego vehcile's:
            i. if the left lane is clear, change to left lane
            ii. if the right lane is clear, change to right lane
            iii. if neither lane is clear, try to reduce speed & match leading vehicle speed.
        if the vehicles distance is below emergency breaking distance:
            emergency brake at maximum deceleration & jerk
    if there is no vehicle in front, or it is above the minimum distance:
        if not in right-most lane:
            if right-lane is clear, and a minimum time was spent in current lane, change lane right
            else, keep current lane.
        if the ego speed is less than target speed:
            increase ego speed by a fraction of maximum acceleration

The minimum time spent in lane is necessary to reduce jerk in the *d* coordinate reference that may occur when the FSM decides to move between two lanes in consecutive time-steps. The minimum time requires a trajectory to be planned for the current lane to last a minimum amount of time before changing lanes again.


#### 5. generateTrajectory()

The trajectory is generated by taking the previous x,y location of the ego vehicle, the current location, and three waypoints separated by a fixed distance by converting from Frenet coordinates and adding that distance, then converting back to x,y. The future waypoints' lane position is determined by the output FSM state, namely, lane changes place the waypoint in the respective lanes. 

The set of waypoints are then converted into the vehicles refernce frame, and are used to fit a spline along these coordinates. The spline is then sampled at x-distance intervals based on an update time of *dt* (in this case, 0.02s), and a speed determined by the FSM module. Since the spline defines coordinates in x,y there is a potential issue that discretization may result in exceeding acceleration and jerk limits.

To set the future motion steps, the previous path steps (if they exits) are taken and new trajectory points from the spline are sampled at the previously determined interval. This ensures that the path generate is partially smoothed by the previously generated trajectory. 